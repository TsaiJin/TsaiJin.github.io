<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>How leveldb log works</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">



<meta name="keywords" content="Share,Knowledge,Learn">








<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/categories/Technology">Technology</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            How leveldb log works
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2020-05-31T13:56:02.000Z" itemprop="datePublished">May 31 2020</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Technology/">Technology</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            19 minutes read (About 2914 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In leveldb, a log file (*.log) stores a sequence of recent updates. Each update is appended to the current log file. </p>
<p>There are several benefits of log file for leveldb:</p>
<ul>
<li>Boosting performance by converting random write into sequential write automatically in the underlying hard drives</li>
<li>Satisfying the atomicity and durability requirements of database properties</li>
</ul>
<p>When the user issues an update operation(put or delete), a corresponding record will be appended to the log file firstly. Only when the record is persisted successfully will a successful status be returned to the user.</p>
<a id="more"></a>


<p>function <code>DBImpl::Write</code> is the critical path for all update operations. Inside this function, statement <code>status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates))</code> appends update information to the current log file. And if it fails, it will return corresponding error code to the upper layer.</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">DBImpl::Write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> WriteOptions&amp; options, WriteBatch* my_batch)</span> </span>{</span><br><span class="line">  <span class="hljs-function">Writer <span class="hljs-title">w</span><span class="hljs-params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = my_batch;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.push_back(&amp;w);</span><br><span class="line">  <span class="hljs-keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) {</span><br><span class="line">    w.cv.Wait();</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">if</span> (w.done) {</span><br><span class="line">    <span class="hljs-keyword">return</span> w.status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// May temporarily unlock and wait.</span></span><br><span class="line">  Status status = MakeRoomForWrite(my_batch == <span class="hljs-literal">NULL</span>);</span><br><span class="line">  <span class="hljs-keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  <span class="hljs-keyword">if</span> (status.ok() &amp;&amp; my_batch != <span class="hljs-literal">NULL</span>) {  <span class="hljs-comment">// NULL batch is for compactions</span></span><br><span class="line">    WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::SetSequence(updates, last_sequence + <span class="hljs-number">1</span>);</span><br><span class="line">    last_sequence += WriteBatchInternal::Count(updates);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line">    <span class="hljs-comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line">    <span class="hljs-comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line">    <span class="hljs-comment">// into mem_.</span></span><br><span class="line">    {</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</span><br><span class="line">      <span class="hljs-keyword">bool</span> sync_error = <span class="hljs-literal">false</span>;</span><br><span class="line">      <span class="hljs-keyword">if</span> (status.ok() &amp;&amp; options.sync) {</span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!status.ok()) {</span><br><span class="line">          sync_error = <span class="hljs-literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="hljs-keyword">if</span> (status.ok()) {</span><br><span class="line">        status = WriteBatchInternal::InsertInto(updates, mem_);</span><br><span class="line">      }</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      <span class="hljs-keyword">if</span> (sync_error) {</span><br><span class="line">        <span class="hljs-comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">        <span class="hljs-comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">        <span class="hljs-comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">if</span> (updates == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</span><br><span class="line">    Writer* <span class="hljs-built_in">ready</span> = writers_.front();</span><br><span class="line">    writers_.pop_front();</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ready</span> != &amp;w) {</span><br><span class="line">      <span class="hljs-built_in">ready</span>-&gt;status = status;</span><br><span class="line">      <span class="hljs-built_in">ready</span>-&gt;done = <span class="hljs-literal">true</span>;</span><br><span class="line">      <span class="hljs-built_in">ready</span>-&gt;cv.Signal();</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ready</span> == last_writer) <span class="hljs-keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (!writers_.empty()) {</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="Layout-of-Log-File"><a href="#Layout-of-Log-File" class="headerlink" title="Layout of Log File"></a>Layout of Log File</h3><p>In a log file, information is stored and retrieved with the unit of <strong>record</strong>. The record consists of two parts: header and payload. The header part is filled with CRC(4 bytes), Length(2 bytes), Type(1 byte). While the payload type is just all the content encapsulated by <a href="http://tsaijin.github.io/2020/05/16/The-mechanism-behind-WriteBatch-in-leveldb">WriteBatch</a> class. </p>
<img src="/2020/05/31/How-leveldb-log-works/record_format.png" class title="image of record format">

<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kHeaderSize = <span class="hljs-number">4</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>A more detailed description about the header:</p>
<ul>
<li>CRC: the crc sum of the record type and the payload</li>
<li>Len: The total length of the payload</li>
<li>Type: The record type, candidates are <code>kFullType</code>, <code>kFirstType</code>, <code>kMiddleType</code> and <code>kLastType</code></li>
</ul>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">Writer::EmitPhysicalRecord</span><span class="hljs-params">(RecordType t, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ptr, <span class="hljs-keyword">size_t</span> n)</span> </span>{</span><br><span class="line">  assert(n &lt;= <span class="hljs-number">0xffff</span>);  <span class="hljs-comment">// Must fit in two bytes</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Format the header</span></span><br><span class="line">  <span class="hljs-keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="hljs-number">4</span>] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(n &amp; <span class="hljs-number">0xff</span>);</span><br><span class="line">  buf[<span class="hljs-number">5</span>] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(n &gt;&gt; <span class="hljs-number">8</span>);</span><br><span class="line">  buf[<span class="hljs-number">6</span>] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="hljs-keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</span><br><span class="line">  crc = crc32c::Mask(crc);                 <span class="hljs-comment">// Adjust for storage</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</span><br><span class="line">  <span class="hljs-keyword">if</span> (s.ok()) {</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, n));</span><br><span class="line">    <span class="hljs-keyword">if</span> (s.ok()) {</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  block_offset_ += kHeaderSize + n;</span><br><span class="line">  <span class="hljs-keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>The block size of log file is designed  to 32KB intentionally. When leveldb tries to append a record to the tail of the log file, it must take block size into consideration.</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kBlockSize = <span class="hljs-number">32768</span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>There are several cases to handle when appending a record:</p>
<ul>
<li><p>The remaining space inside a block cannot even accommodate the header(kHeaderSize = 7 bytes)</p>
</li>
<li><p>The remainning space inside a block can accommodate  the whole record</p>
</li>
<li><p>The whole record consumes space across two continuous blocks</p>
</li>
<li><p>The whole record consumes space across multiple(at least three) continuous blocks</p>
</li>
</ul>
<p>Now, let&#x2019;s talk about the first case: <strong>The remaining space inside a block cannot even accommodate the header(kHeaderSize = 7 bytes)</strong>.</p>
<p>Because each record must begin with a header, so when the remaning space inside a block is not enough to handle the header, the remaning space will be just padding with dummy data and the next continuous block will be chosen as an operating block.</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">assert(leftover &gt;= <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize) {</span><br><span class="line">	<span class="hljs-comment">// Switch to a new block</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>) {</span><br><span class="line">  <span class="hljs-comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">  assert(kHeaderSize == <span class="hljs-number">7</span>);</span><br><span class="line">  dest_-&gt;Append(Slice(<span class="hljs-string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">  }</span><br><span class="line">  block_offset_ = <span class="hljs-number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<img src="/2020/05/31/How-leveldb-log-works/record_not_for_header.png" class title="image of dummy data">



<p>Obviously, the new block will begin to handle the record.</p>
<p>Second case: <strong>The remaining space inside a block can accommodate  the whole record</strong>. In this case, a record with type <code>kFullType</code> will be appended to this block and the payload field contains all the data.</p>
<img src="/2020/05/31/How-leveldb-log-works/record_within_one_block.png" class title="image of full record">



<p>Third case: <strong>The whole record consumes space across two continuous blocks</strong>. The record will be splitted into two subrecords, the first subrecord is <code>kFirstType</code> type and the second subrecord is <code>kLastType</code> type.</p>
<img src="/2020/05/31/How-leveldb-log-works/record_across_two_blocks.png" class title="image of across two blocks">



<p>Fourth case: <strong>The whole record consumes space across multiple(at least three) continuous blocks</strong>. The record will be splitted into multiple subrecords. The first subrecord is <code>kFirstType</code> type and the last subrecord is <code>kLastType</code> type, all the other subrecords are <code>kMiddleType</code> type.</p>
<img src="/2020/05/31/How-leveldb-log-works/record_across_multipe_blocks.png" class title="image of across multiple blocks">

<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">Writer::AddRecord</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slice&amp; slice)</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="hljs-keyword">size_t</span> left = slice.<span class="hljs-built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="hljs-comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="hljs-comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="hljs-keyword">bool</span> <span class="hljs-built_in">begin</span> = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">do</span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    assert(leftover &gt;= <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize) {</span><br><span class="line">      <span class="hljs-comment">// Switch to a new block</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>) {</span><br><span class="line">        <span class="hljs-comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        assert(kHeaderSize == <span class="hljs-number">7</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="hljs-string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      }</span><br><span class="line">      block_offset_ = <span class="hljs-number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> <span class="hljs-built_in">end</span> = (left == fragment_length);</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">begin</span> &amp;&amp; <span class="hljs-built_in">end</span>) {</span><br><span class="line">      type = kFullType;</span><br><span class="line">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">begin</span>) {</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">end</span>) {</span><br><span class="line">      type = kLastType;</span><br><span class="line">    } <span class="hljs-keyword">else</span> {</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    <span class="hljs-built_in">begin</span> = <span class="hljs-literal">false</span>;</span><br><span class="line">  } <span class="hljs-keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="hljs-number">0</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>In summary, <strong>no physical record on the disk is allowed to persist across blocks.</strong></p>
<h3 id="Log-Recovery"><a href="#Log-Recovery" class="headerlink" title="Log Recovery"></a>Log Recovery</h3><p>Leveldb will call <code>DBImpl::Recover</code> to try to recover data from the log file when a database is opened each time. Function <code>DBImpl::Recover</code> replays all existing log files with the help of function <code>DBImpl::RecoverLogFile</code> in chronological order.</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line">  <span class="hljs-comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line">  <span class="hljs-comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line">  <span class="hljs-comment">//</span></span><br><span class="line">  <span class="hljs-comment">// Note that PrevLogNumber() is no longer used, but we pay</span></span><br><span class="line">  <span class="hljs-comment">// attention to it in case we are recovering a database</span></span><br><span class="line">  <span class="hljs-comment">// produced by an older version of leveldb.</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</span><br><span class="line">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; filenames;</span><br><span class="line">  s = env_-&gt;GetChildren(dbname_, &amp;filenames);</span><br><span class="line">  <span class="hljs-keyword">if</span> (!s.ok()) {</span><br><span class="line">    <span class="hljs-keyword">return</span> s;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt; expected;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;expected);</span><br><span class="line">  <span class="hljs-keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt; logs;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; filenames.<span class="hljs-built_in">size</span>(); i++) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) {</span><br><span class="line">      expected.erase(number);</span><br><span class="line">      <span class="hljs-keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">        logs.push_back(number);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">if</span> (!expected.empty()) {</span><br><span class="line">    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">50</span>];</span><br><span class="line">    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;%d missing files; e.g.&quot;</span>,</span><br><span class="line">             <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(expected.<span class="hljs-built_in">size</span>()));</span><br><span class="line">    <span class="hljs-keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.<span class="hljs-built_in">begin</span>())));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Recover in the order in which the logs were generated</span></span><br><span class="line">  <span class="hljs-built_in">std</span>::sort(logs.<span class="hljs-built_in">begin</span>(), logs.<span class="hljs-built_in">end</span>());</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; logs.<span class="hljs-built_in">size</span>(); i++) {</span><br><span class="line">    s = RecoverLogFile(logs[i], (i == logs.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>), save_manifest, edit,</span><br><span class="line">                       &amp;max_sequence);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!s.ok()) {</span><br><span class="line">      <span class="hljs-keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="hljs-comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="hljs-comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>In function <code>DBImpl::RecoverLogFile</code>, it will read the log file sequentially from beginning to end.</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">DBImpl::RecoverLogFile</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> log_number, <span class="hljs-keyword">bool</span> last_log,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">bool</span>* save_manifest, VersionEdit* edit,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                              SequenceNumber* max_sequence)</span> </span>{</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LogReporter</span> :</span> <span class="hljs-keyword">public</span> <span class="hljs-built_in">log</span>::Reader::Reporter {</span><br><span class="line">    Env* env;</span><br><span class="line">    Logger* info_log;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname;</span><br><span class="line">    Status* status;  <span class="hljs-comment">// NULL if options_.paranoid_checks==false</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Corruption</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> bytes, <span class="hljs-keyword">const</span> Status&amp; s)</span> </span>{</span><br><span class="line">      Log(info_log, <span class="hljs-string">&quot;%s%s: dropping %d bytes; %s&quot;</span>,</span><br><span class="line">          (<span class="hljs-keyword">this</span>-&gt;status == <span class="hljs-literal">NULL</span> ? <span class="hljs-string">&quot;(ignoring error) &quot;</span> : <span class="hljs-string">&quot;&quot;</span>),</span><br><span class="line">          fname, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(bytes), s.ToString().c_str());</span><br><span class="line">      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;status != <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-keyword">this</span>-&gt;status-&gt;ok()) *<span class="hljs-keyword">this</span>-&gt;status = s;</span><br><span class="line">    }</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Open the log file</span></span><br><span class="line">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fname = LogFileName(dbname_, log_number);</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  Status status = env_-&gt;NewSequentialFile(fname, &amp;file);</span><br><span class="line">  <span class="hljs-keyword">if</span> (!status.ok()) {</span><br><span class="line">    MaybeIgnoreError(&amp;status);</span><br><span class="line">    <span class="hljs-keyword">return</span> status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Create the log reader.</span></span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.env = env_;</span><br><span class="line">  reporter.info_log = options_.info_log;</span><br><span class="line">  reporter.fname = fname.c_str();</span><br><span class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="hljs-literal">NULL</span>);</span><br><span class="line">  <span class="hljs-comment">// We intentionally make log::Reader do checksumming even if</span></span><br><span class="line">  <span class="hljs-comment">// paranoid_checks==false so that corruptions cause entire commits</span></span><br><span class="line">  <span class="hljs-comment">// to be skipped instead of propagating bad information (like overly</span></span><br><span class="line">  <span class="hljs-comment">// large sequence numbers).</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-built_in">log</span>::Reader <span class="hljs-title">reader</span><span class="hljs-params">(file, &amp;reporter, <span class="hljs-literal">true</span><span class="hljs-comment">/*checksum*/</span>,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-number">0</span><span class="hljs-comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">  Log(options_.info_log, <span class="hljs-string">&quot;Recovering log #%llu&quot;</span>,</span><br><span class="line">      (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) log_number);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Read all the records and add to a memtable</span></span><br><span class="line">  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> scratch;</span><br><span class="line">  Slice record;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  <span class="hljs-keyword">int</span> compactions = <span class="hljs-number">0</span>;</span><br><span class="line">  MemTable* mem = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  <span class="hljs-keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp;</span><br><span class="line">         status.ok()) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (record.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">12</span>) {</span><br><span class="line">      reporter.Corruption(</span><br><span class="line">          record.<span class="hljs-built_in">size</span>(), Status::Corruption(<span class="hljs-string">&quot;log record too small&quot;</span>));</span><br><span class="line">      <span class="hljs-keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    WriteBatchInternal::SetContents(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (mem == <span class="hljs-literal">NULL</span>) {</span><br><span class="line">      mem = <span class="hljs-keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem-&gt;Ref();</span><br><span class="line">    }</span><br><span class="line">    status = WriteBatchInternal::InsertInto(&amp;batch, mem);</span><br><span class="line">    MaybeIgnoreError(&amp;status);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!status.ok()) {</span><br><span class="line">      <span class="hljs-keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">const</span> SequenceNumber last_seq =</span><br><span class="line">        WriteBatchInternal::Sequence(&amp;batch) +</span><br><span class="line">        WriteBatchInternal::Count(&amp;batch) - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (last_seq &gt; *max_sequence) {</span><br><span class="line">      *max_sequence = last_seq;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) {</span><br><span class="line">      compactions++;</span><br><span class="line">      *save_manifest = <span class="hljs-literal">true</span>;</span><br><span class="line">      status = WriteLevel0Table(mem, edit, <span class="hljs-literal">NULL</span>);</span><br><span class="line">      mem-&gt;Unref();</span><br><span class="line">      mem = <span class="hljs-literal">NULL</span>;</span><br><span class="line">      <span class="hljs-keyword">if</span> (!status.ok()) {</span><br><span class="line">        <span class="hljs-comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">        <span class="hljs-comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">delete</span> file;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// See if we should keep reusing the last log file.</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (status.ok() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="hljs-number">0</span>) {</span><br><span class="line">    assert(logfile_ == <span class="hljs-literal">NULL</span>);</span><br><span class="line">    assert(log_ == <span class="hljs-literal">NULL</span>);</span><br><span class="line">    assert(mem_ == <span class="hljs-literal">NULL</span>);</span><br><span class="line">    <span class="hljs-keyword">uint64_t</span> lfile_size;</span><br><span class="line">    <span class="hljs-keyword">if</span> (env_-&gt;GetFileSize(fname, &amp;lfile_size).ok() &amp;&amp;</span><br><span class="line">        env_-&gt;NewAppendableFile(fname, &amp;logfile_).ok()) {</span><br><span class="line">      Log(options_.info_log, <span class="hljs-string">&quot;Reusing old log %s \n&quot;</span>, fname.c_str());</span><br><span class="line">      log_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">log</span>::Writer(logfile_, lfile_size);</span><br><span class="line">      logfile_number_ = log_number;</span><br><span class="line">      <span class="hljs-keyword">if</span> (mem != <span class="hljs-literal">NULL</span>) {</span><br><span class="line">        mem_ = mem;</span><br><span class="line">        mem = <span class="hljs-literal">NULL</span>;</span><br><span class="line">      } <span class="hljs-keyword">else</span> {</span><br><span class="line">        <span class="hljs-comment">// mem can be NULL if lognum exists but was empty.</span></span><br><span class="line">        mem_ = <span class="hljs-keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">        mem_-&gt;Ref();</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (mem != <span class="hljs-literal">NULL</span>) {</span><br><span class="line">    <span class="hljs-comment">// mem did not get reused; compact it.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (status.ok()) {</span><br><span class="line">      *save_manifest = <span class="hljs-literal">true</span>;</span><br><span class="line">      status = WriteLevel0Table(mem, edit, <span class="hljs-literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> status;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>In function <code>Reader::ReadRecord</code>, there are several important variables:</p>
<ul>
<li><code>initial_offset_</code>: Offset at which to start looking for the first record to return. It is initialized in the Reader constructor function</li>
<li><code>last_record_offset_</code>: Offset of the last record returned by ReadRecord</li>
</ul>
<p>If <code>last_record_offset_</code> is less than <code>initial_offset_</code>, it will call <code>Reader::ReadRecord</code> to go to the correct block position to read the next record:</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Reader::SkipToInitialBlock</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="hljs-keyword">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Don&apos;t search a block if we&apos;d be in the trailer</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="hljs-number">6</span>) {</span><br><span class="line">    offset_in_block = <span class="hljs-number">0</span>;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (block_start_location &gt; <span class="hljs-number">0</span>) {</span><br><span class="line">    Status skip_status = file_-&gt;Skip(block_start_location);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!skip_status.ok()) {</span><br><span class="line">      ReportDrop(block_start_location, skip_status);</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>As we see, a logical record maybe splitted into multiple subrecords. So there is another function named <code>Reader::ReadPhysicalRecord</code> to read the physical record on disk. </p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Reader::ReadPhysicalRecord</span><span class="hljs-params">(Slice* result)</span> </span>{</span><br><span class="line">  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (buffer_.<span class="hljs-built_in">size</span>() &lt; kHeaderSize) {</span><br><span class="line">      <span class="hljs-keyword">if</span> (!eof_) {</span><br><span class="line">        <span class="hljs-comment">// Last read was a full read, so this is a trailer to skip</span></span><br><span class="line">        buffer_.<span class="hljs-built_in">clear</span>();</span><br><span class="line">        Status status = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);</span><br><span class="line">        end_of_buffer_offset_ += buffer_.<span class="hljs-built_in">size</span>();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!status.ok()) {</span><br><span class="line">          buffer_.<span class="hljs-built_in">clear</span>();</span><br><span class="line">          ReportDrop(kBlockSize, status);</span><br><span class="line">          eof_ = <span class="hljs-literal">true</span>;</span><br><span class="line">          <span class="hljs-keyword">return</span> kEof;</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_.<span class="hljs-built_in">size</span>() &lt; kBlockSize) {</span><br><span class="line">          eof_ = <span class="hljs-literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line">      } <span class="hljs-keyword">else</span> {</span><br><span class="line">        <span class="hljs-comment">// Note that if buffer_ is non-empty, we have a truncated header at the</span></span><br><span class="line">        <span class="hljs-comment">// end of the file, which can be caused by the writer crashing in the</span></span><br><span class="line">        <span class="hljs-comment">// middle of writing the header. Instead of considering this an error,</span></span><br><span class="line">        <span class="hljs-comment">// just report EOF.</span></span><br><span class="line">        buffer_.<span class="hljs-built_in">clear</span>();</span><br><span class="line">        <span class="hljs-keyword">return</span> kEof;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Parse the header</span></span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* header = buffer_.data();</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> a = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(header[<span class="hljs-number">4</span>]) &amp; <span class="hljs-number">0xff</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> b = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(header[<span class="hljs-number">5</span>]) &amp; <span class="hljs-number">0xff</span>;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> type = header[<span class="hljs-number">6</span>];</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> length = a | (b &lt;&lt; <span class="hljs-number">8</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="hljs-built_in">size</span>()) {</span><br><span class="line">      <span class="hljs-keyword">size_t</span> drop_size = buffer_.<span class="hljs-built_in">size</span>();</span><br><span class="line">      buffer_.<span class="hljs-built_in">clear</span>();</span><br><span class="line">      <span class="hljs-keyword">if</span> (!eof_) {</span><br><span class="line">        ReportCorruption(drop_size, <span class="hljs-string">&quot;bad record length&quot;</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> kBadRecord;</span><br><span class="line">      }</span><br><span class="line">      <span class="hljs-comment">// If the end of the file has been reached without reading |length| bytes</span></span><br><span class="line">      <span class="hljs-comment">// of payload, assume the writer died in the middle of writing the record.</span></span><br><span class="line">      <span class="hljs-comment">// Don&apos;t report a corruption.</span></span><br><span class="line">      <span class="hljs-keyword">return</span> kEof;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (type == kZeroType &amp;&amp; length == <span class="hljs-number">0</span>) {</span><br><span class="line">      <span class="hljs-comment">// Skip zero length record without reporting any drops since</span></span><br><span class="line">      <span class="hljs-comment">// such records are produced by the mmap based writing code in</span></span><br><span class="line">      <span class="hljs-comment">// env_posix.cc that preallocates file regions.</span></span><br><span class="line">      buffer_.<span class="hljs-built_in">clear</span>();</span><br><span class="line">      <span class="hljs-keyword">return</span> kBadRecord;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Check crc</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (checksum_) {</span><br><span class="line">      <span class="hljs-keyword">uint32_t</span> expected_crc = crc32c::Unmask(DecodeFixed32(header));</span><br><span class="line">      <span class="hljs-keyword">uint32_t</span> actual_crc = crc32c::Value(header + <span class="hljs-number">6</span>, <span class="hljs-number">1</span> + length);</span><br><span class="line">      <span class="hljs-keyword">if</span> (actual_crc != expected_crc) {</span><br><span class="line">        <span class="hljs-comment">// Drop the rest of the buffer since &quot;length&quot; itself may have</span></span><br><span class="line">        <span class="hljs-comment">// been corrupted and if we trust it, we could find some</span></span><br><span class="line">        <span class="hljs-comment">// fragment of a real log record that just happens to look</span></span><br><span class="line">        <span class="hljs-comment">// like a valid log record.</span></span><br><span class="line">        <span class="hljs-keyword">size_t</span> drop_size = buffer_.<span class="hljs-built_in">size</span>();</span><br><span class="line">        buffer_.<span class="hljs-built_in">clear</span>();</span><br><span class="line">        ReportCorruption(drop_size, <span class="hljs-string">&quot;checksum mismatch&quot;</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> kBadRecord;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buffer_.remove_prefix(kHeaderSize + length);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Skip physical record that started before initial_offset_</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (end_of_buffer_offset_ - buffer_.<span class="hljs-built_in">size</span>() - kHeaderSize - length &lt;</span><br><span class="line">        initial_offset_) {</span><br><span class="line">      result-&gt;<span class="hljs-built_in">clear</span>();</span><br><span class="line">      <span class="hljs-keyword">return</span> kBadRecord;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *result = Slice(header + kHeaderSize, length);</span><br><span class="line">    <span class="hljs-keyword">return</span> type;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>In <code>Reader::ReadPhysicalRecord</code>, it will parse the record header to get crc value and length value. With this information, it can check whether the data is intact or not.</p>
<p>And if multiple physical records belong to one logical record, the <code>Reader::ReadRecord</code> will combine them together and return to the upper layer:</p>
<p></p><figure class="highlight c++ hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> record_type = ReadPhysicalRecord(&amp;fragment);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// ReadPhysicalRecord may have only had an empty trailer remaining in its</span></span><br><span class="line">    <span class="hljs-comment">// internal buffer. Calculate the offset of the next physical record now</span></span><br><span class="line">    <span class="hljs-comment">// that it has returned, properly accounting for its header size.</span></span><br><span class="line">    <span class="hljs-keyword">uint64_t</span> physical_record_offset =</span><br><span class="line">        end_of_buffer_offset_ - buffer_.<span class="hljs-built_in">size</span>() - kHeaderSize - fragment.<span class="hljs-built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (resyncing_) {</span><br><span class="line">      <span class="hljs-keyword">if</span> (record_type == kMiddleType) {</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line">      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record_type == kLastType) {</span><br><span class="line">        resyncing_ = <span class="hljs-literal">false</span>;</span><br><span class="line">        <span class="hljs-keyword">continue</span>;</span><br><span class="line">      } <span class="hljs-keyword">else</span> {</span><br><span class="line">        resyncing_ = <span class="hljs-literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (record_type) {</span><br><span class="line">      <span class="hljs-keyword">case</span> kFullType:</span><br><span class="line">        <span class="hljs-keyword">if</span> (in_fragmented_record) {</span><br><span class="line">          <span class="hljs-comment">// Handle bug in earlier versions of log::Writer where</span></span><br><span class="line">          <span class="hljs-comment">// it could emit an empty kFirstType record at the tail end</span></span><br><span class="line">          <span class="hljs-comment">// of a block followed by a kFullType or kFirstType record</span></span><br><span class="line">          <span class="hljs-comment">// at the beginning of the next block.</span></span><br><span class="line">          <span class="hljs-keyword">if</span> (scratch-&gt;empty()) {</span><br><span class="line">            in_fragmented_record = <span class="hljs-literal">false</span>;</span><br><span class="line">          } <span class="hljs-keyword">else</span> {</span><br><span class="line">            ReportCorruption(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;partial record without end(1)&quot;</span>);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;<span class="hljs-built_in">clear</span>();</span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">case</span> kFirstType:</span><br><span class="line">        <span class="hljs-keyword">if</span> (in_fragmented_record) {</span><br><span class="line">          <span class="hljs-comment">// Handle bug in earlier versions of log::Writer where</span></span><br><span class="line">          <span class="hljs-comment">// it could emit an empty kFirstType record at the tail end</span></span><br><span class="line">          <span class="hljs-comment">// of a block followed by a kFullType or kFirstType record</span></span><br><span class="line">          <span class="hljs-comment">// at the beginning of the next block.</span></span><br><span class="line">          <span class="hljs-keyword">if</span> (scratch-&gt;empty()) {</span><br><span class="line">            in_fragmented_record = <span class="hljs-literal">false</span>;</span><br><span class="line">          } <span class="hljs-keyword">else</span> {</span><br><span class="line">            ReportCorruption(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;partial record without end(2)&quot;</span>);</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;assign(fragment.data(), fragment.<span class="hljs-built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="hljs-literal">true</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="hljs-keyword">if</span> (!in_fragmented_record) {</span><br><span class="line">          ReportCorruption(fragment.<span class="hljs-built_in">size</span>(),</span><br><span class="line">                           <span class="hljs-string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        } <span class="hljs-keyword">else</span> {</span><br><span class="line">          scratch-&gt;append(fragment.data(), fragment.<span class="hljs-built_in">size</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">case</span> kLastType:</span><br><span class="line">        <span class="hljs-keyword">if</span> (!in_fragmented_record) {</span><br><span class="line">          ReportCorruption(fragment.<span class="hljs-built_in">size</span>(),</span><br><span class="line">                           <span class="hljs-string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        } <span class="hljs-keyword">else</span> {</span><br><span class="line">          scratch-&gt;append(fragment.data(), fragment.<span class="hljs-built_in">size</span>());</span><br><span class="line">          *record = Slice(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">case</span> kEof:</span><br><span class="line">        <span class="hljs-keyword">if</span> (in_fragmented_record) {</span><br><span class="line">          <span class="hljs-comment">// This can be caused by the writer dying immediately after</span></span><br><span class="line">          <span class="hljs-comment">// writing a physical record but before completing the next; don&apos;t</span></span><br><span class="line">          <span class="hljs-comment">// treat it as a corruption, just ignore the entire logical record.</span></span><br><span class="line">          scratch-&gt;<span class="hljs-built_in">clear</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">case</span> kBadRecord:</span><br><span class="line">        <span class="hljs-keyword">if</span> (in_fragmented_record) {</span><br><span class="line">          ReportCorruption(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;error in middle of record&quot;</span>);</span><br><span class="line">          in_fragmented_record = <span class="hljs-literal">false</span>;</span><br><span class="line">          scratch-&gt;<span class="hljs-built_in">clear</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">default</span>: {</span><br><span class="line">        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">40</span>];</span><br><span class="line">        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;unknown record type %u&quot;</span>, record_type);</span><br><span class="line">        ReportCorruption(</span><br><span class="line">            (fragment.<span class="hljs-built_in">size</span>() + (in_fragmented_record ? scratch-&gt;<span class="hljs-built_in">size</span>() : <span class="hljs-number">0</span>)),</span><br><span class="line">            buf);</span><br><span class="line">        in_fragmented_record = <span class="hljs-literal">false</span>;</span><br><span class="line">        scratch-&gt;<span class="hljs-built_in">clear</span>();</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>From the code above, we know that in normal cases only when a record type of <code>kFullType</code> or <code>kLastType</code> is met can the function return to the upper layer.</p>
<p>And the upper layer replays the whole operation based on the logical record information returned by <code>Reader::ReadRecord</code>. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>This blog mainly talks about how log mechanism works in leveldb. Have fun<del>~</del></p>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/database/">#database</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/leveldb/">#leveldb</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-prev">
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2020/05/16/The-mechanism-behind-WriteBatch-in-leveldb/">The mechanism behind WriteBatch in leveldb</a>
            
        </span>
    </div>
    
</article>




<div class="comments">
    <h3 class="title is-4">Comments</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'http://tsaijin.github.io/2020/05/31/How-leveldb-log-works/';
        this.page.identifier = '2020/05/31/How-leveldb-log-works/';
        
        this.language = 'en';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'tsaijin' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
</div>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2020 Jin Cai&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>




<script src="/js/script.js"></script>


    
</body>
</html>