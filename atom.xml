<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mind &amp; Hand</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tsaijin.github.io/"/>
  <updated>2020-04-13T11:45:24.247Z</updated>
  <id>http://tsaijin.github.io/</id>
  
  <author>
    <name>Jin Tsai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redo log in InnoDB</title>
    <link href="http://tsaijin.github.io/2016/07/09/Redo-log-in-InnoDB/"/>
    <id>http://tsaijin.github.io/2016/07/09/Redo-log-in-InnoDB/</id>
    <published>2016-07-09T09:13:59.000Z</published>
    <updated>2020-04-13T11:45:24.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-redo-log"><a href="#What-is-redo-log" class="headerlink" title="What is redo log"></a>What is redo log</h2><p>For a relational database, ACID is a set of properties that it must support for a transaction. That is to say, a transaction should be atomic, consistent, isolated and durable under the management of such database.<br>InnoDB, the default storage engine since MySQL 5.5, use a method called <strong>redo log</strong> to implement the durability of a transaction. Redo log consists of redo log buffer and redo log file.<br>The redo log buffer resides in memory and is volatile while the redo log file resides in disks and is durable. Redo log records the information about a transaction. As the literal meaning of words redo log denotes, you can redo your operations after the system crashes by redo log.</p><h2 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work"></a>How does it work</h2><p>As a transaction-based storage engine, InnoDB uses “force log at commit” mechanism to achieve  durability.<br>So before a transaction is committed, all logs of that transaction must be flushed to redo log files. Even though the whole system crashes during the process of transaction commit, this transaction can be recovered by the redo log file after the system boots up again.<br>There exist a redo log memory buffer where the redo log is written to boost system performance. To ensure that redo log is written to redo log file successfully each time, the InnoDB storage engine need to call the <code>fsync</code> because <code>O_DIRECT</code> flag is not used when open redo log so that redo log is written to file system buffer firstly. Nevertheless, the time consumed by <code>fsync</code> call is up to the performance of disk. Consequently, the performance of disk determines the performance of transaction commit.<a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html" target="_blank" rel="noopener">Reference1</a></p><p>Taking account of the performance problem mentioned previously, the InnoDB storage engine allows user to set up the frequency of calling <code>fsync</code>. Specifically, parameter <code>innodb_flush_log_at_trx_commit</code> is used for frequency management. <code>innodb_flush_log_at_trx_commit</code> controls the balance between strict ACID compliance for commit operations, and higher performance that is possible when commit-related I/O operations are rearranged and done in batches. You can achieve better performance by changing the default value, but then you can lose up to a second of transactions in a crash.  </p><ul><li>The default value of 1 is required for full ACID compliance. With this value, the contents of the InnoDB log buffer are written out to the log file at each transaction commit and the log file is flushed to disk.  </li><li>With a value of 0, the contents of the InnoDB log buffer are written to the log file approximately once per second and the log file is flushed to disk. No writes from the log buffer to the log file are performed at transaction commit. Once-per-second flushing is not 100% guaranteed to happen every second, due to process scheduling issues. Because the flush to disk operation only occurs approximately once per second, you can lose up to a second of transactions with any mysqld process crash</li><li>With a value of 2, the contents of the InnoDB log buffer are written to the log file after each transaction commit and the log file is flushed to disk approximately once per second. Once-per-second flushing is not 100% guaranteed to happen every second, due to process scheduling issues. Because the flush to disk operation only occurs approximately once per second, you can lose up to a second of transactions in an operating system crash or a power outage.<a href="https://book.douban.com/subject/25872763/" target="_blank" rel="noopener">Reference2</a></li></ul><h2 id="The-format-of-redo-log-file"><a href="#The-format-of-redo-log-file" class="headerlink" title="The format of redo log file"></a>The format of redo log file</h2><p>In InnoDB storage engine, the redo logs are stored in 512-byte format. This means that redo log cache, redo log files are both kept in blocks and each bock has a size of 512 bytes. Besides the log itself in block, log block header and lock block tailer are also stored in each block. In a redo log block, 12 bytes and 8 bytes are occupied by redo log header and redo log tailer respectively(So real information stored in each block is 492 bytes).<br><img src="/images/redo-log/1.jpg" alt="redo-log-block">  </p>]]></content>
    
    <summary type="html">
    
      Mechanism of redo log
    
    </summary>
    
      <category term="Database" scheme="http://tsaijin.github.io/categories/Database/"/>
    
    
      <category term="database" scheme="http://tsaijin.github.io/tags/database/"/>
    
      <category term="mysql" scheme="http://tsaijin.github.io/tags/mysql/"/>
    
      <category term="storage" scheme="http://tsaijin.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>Compile your own linux kernel</title>
    <link href="http://tsaijin.github.io/2016/04/23/Compile-your-own-linux-kernel/"/>
    <id>http://tsaijin.github.io/2016/04/23/Compile-your-own-linux-kernel/</id>
    <published>2016-04-23T03:18:21.000Z</published>
    <updated>2020-04-13T11:45:24.247Z</updated>
    
    <content type="html"><![CDATA[<p>As we know, linux is one of the greatest open source projects in the world  and serves millions of enterprises.  An open source project means that you can define your own features catering to  different application scenarios. All big Internet firms such as Google, Facebook and Aamazon recompile the linux kernel so that features can be added to or removed from the official kernel release version.<br>Compiling the kernel for linux kernel developers is also unavoidable. In the rest part of this post, attention will focus on tutorials on compiling a linux kernel.   </p><a id="more"></a><h3 id="1-Getting-the-kernel-source-of-official-release"><a href="#1-Getting-the-kernel-source-of-official-release" class="headerlink" title="1. Getting the kernel source of official release"></a>1. Getting the kernel source of official release</h3><p>Nothing comes from nothing. So the first thing before compiling a customized kernel is getting source code.<br>I strongly recommend using <code>Git</code> to download and manage the linux kernel source:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> source_git_link</span><br></pre></td></tr></table></figure><p>Surely, you can also download the compressed package of source code and then uncompress it.<br>Go to the source code root directory, there exists a number of directories under it.   </p><p><img src="/images/compile-kernel/1.png" alt="Directories"></p><p>The following table[1] illustrates explanation about these directories.    </p><table><thead><tr><th style="text-align:center">Directory</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">arch</td><td style="text-align:center">Architecture-specific source</td></tr><tr><td style="text-align:center">block</td><td style="text-align:center">Block I/O layer</td></tr><tr><td style="text-align:center">certs</td><td style="text-align:center">SSL/TLS certification</td></tr><tr><td style="text-align:center">crypto</td><td style="text-align:center">Crypto API</td></tr><tr><td style="text-align:center">Documentation</td><td style="text-align:center">Kernel source documentation</td></tr><tr><td style="text-align:center">drivers</td><td style="text-align:center">drivers Device</td></tr><tr><td style="text-align:center">firmware</td><td style="text-align:center">Device firmware needed to use certain drivers</td></tr><tr><td style="text-align:center">fs</td><td style="text-align:center">The VFS and the individual filesystems</td></tr><tr><td style="text-align:center">include</td><td style="text-align:center">Kernel headers</td></tr><tr><td style="text-align:center">init</td><td style="text-align:center">Kernel boot and initialization</td></tr><tr><td style="text-align:center">ipc</td><td style="text-align:center">Interprocess communication code</td></tr><tr><td style="text-align:center">kernel</td><td style="text-align:center">Core subsystems, such as the scheduler</td></tr><tr><td style="text-align:center">lib</td><td style="text-align:center">Helper routines</td></tr><tr><td style="text-align:center">mm</td><td style="text-align:center">Memory management subsystem and the VM</td></tr><tr><td style="text-align:center">net</td><td style="text-align:center">Networking subsystem</td></tr><tr><td style="text-align:center">samples</td><td style="text-align:center">Sample, demonstrative code</td></tr><tr><td style="text-align:center">scripts</td><td style="text-align:center">Scripts used to build the kernel</td></tr><tr><td style="text-align:center">security</td><td style="text-align:center">Linux Security Module</td></tr><tr><td style="text-align:center">sound</td><td style="text-align:center">Sound subsystem</td></tr><tr><td style="text-align:center">usr</td><td style="text-align:center">Early user-space code (called initramfs)</td></tr><tr><td style="text-align:center">tools</td><td style="text-align:center">Tools helpful for developing Linux</td></tr><tr><td style="text-align:center">virt</td><td style="text-align:center">Virtualization infrastructure</td></tr></tbody></table><h3 id="2-Building-the-kernel-source-code"><a href="#2-Building-the-kernel-source-code" class="headerlink" title="2. Building the kernel source code"></a>2. Building the kernel source code</h3><p>After the first step, you come here.  Now what you should do is configuring the kernel before compiling. As mentioned previously, it is possible to compile support into your kernel for only the specific features and drivers you want. Configuring the kernel is a required process before building it. By default, the kernel of official release version provides myriad features and supports a varied basket of hardware. </p><h4 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="(1). Configuration"></a>(1). Configuration</h4><p>when you change your current working directory to the root directory of linux kernel source code, you will find there is a file named <strong>.config</strong>. Using command such as <code>cat .config | more</code> you can take a glimpse of its content.  </p><pre><code class="bash">cat .config | more</code></pre><p><img src="/images/compile-kernel/2.png" alt="Configurations"></p><p>As shown in the picture, kernel configuration is controlled by configuration options, which are prefixed by <strong>CONFIG</strong> in the form <strong>CONFIG_FEATURE</strong>. That is to say, asynchronous IO is controlled by the configuration option <strong>CONFIG_AIO</strong>. This option enables POSIX asynchronous I/O which may by used by some high performance threaded applications[Reference][2]. When this option is set, AIO is enabled; if unset, AIO is disabled.<br>Configuration options that control the build process are either Booleans or tristates. A Boolean option is either yes or no. Kernel features, such as CONFIG_PREEMPT, are usually Booleans. A tristate option is one of yes, no, or module.The module setting represents a configuration option that is set but is to be compiled as a module (that is, a separate dynamically loadable object). In the case of tristates, a yes option explicitly means to compile the code into the main kernel image and not as a module. Drivers are usually represented by tristates[Reference][3].<br>Configuration options can also be strings or integers.These options do not control the build process but instead specify values that kernel source can access as a preprocessor macro. For example, a configuration option can specify the size of a statically allocated array[Reference][4].<br>Kernel provides multiple choices for you to facilitate configurations. A straightfoward way is using a graphical interactive interface: <code>make menuconfig</code>.    </p><pre><code class="bash">make menuconfig</code></pre><p> After typing this command, a graphical interactive interface will appears in your screen like this:<br><img src="/images/compile-kernel/3.png" alt="Menuconfig"><br>And you can move the cursor to different options to set them. Because of space, how to configure these options correctly can not be presented. For more detailed knowledge, you can find them in the linux orgnization.    </p><h4 id="2-Compile-and-build"><a href="#2-Compile-and-build" class="headerlink" title="(2). Compile and build"></a>(2). Compile and build</h4><p>Now, it is time to get into the marrow of the second part: Compile &amp;&amp; Build. Please make sure that command <code>make</code> and <code>gcc</code> is installed on your machine firstly.<br>Just type <code>make</code> and all related source code about kernel will be compiled and built, the default Makefile rule will handle everything.    </p><pre><code class="bash">make</code></pre><p>In general, one flaw about the <code>make</code> method is that this action spawns only a single job because Makefiles all too often have incorrect dependency information. With incorrect dependencies, multiple jobs can step on each other’s toes, resulting in errors in the build process. However, The kernel’s Makefile have correct dependency information, so spawning multiple jobs does not result in failures. To build the kernel with multiple make jobs, use    </p><pre><code class="bash">make -jn</code></pre><p>The n here is number of jobs to spawn. Usual practice is to spawn one or two jobs per processor. If you have 16 processors in you machine, then you might do    </p><pre><code class="bash">make -j32</code></pre><p>The resulting kernel file is “arch/x86/boot/bzImage” (in x86 platform).  </p><h3 id="3-Installation"><a href="#3-Installation" class="headerlink" title="3. Installation"></a>3. Installation</h3><p>After the kernel is built, you can install it. It is possible that the kernel you install cannot boot successfully, so in case of that, you should have at least two kernel installed on you machine so that you can choose the another one to boot.  </p><h4 id="1-Install-modules"><a href="#1-Install-modules" class="headerlink" title="(1). Install modules"></a>(1). Install modules</h4><p>Installing modules, thankfully, is automated and architecture-independent. As root, simply run  </p><pre><code class="bash">make modules_install</code></pre><p>After this, you will find a module file under <strong>/lib/modules/a.b.c</strong> where a.b.c is the kernel version.   </p><h4 id="2-Install-kernel"><a href="#2-Install-kernel" class="headerlink" title="(2). Install kernel"></a>(2). Install kernel</h4><p>As root user, simply run    </p><pre><code class="bash">make install</code></pre><p>After this, a new kernel file and a new boot image will appear in the <strong>/boot</strong> directory.  </p><h4 id="3-Set-booting-order"><a href="#3-Set-booting-order" class="headerlink" title="(3). Set booting order"></a>(3). Set booting order</h4><p>If you execute all the steps normally,  new content about the new installed kernel has been added to <strong>/boot/grub/grub.conf</strong> file. And you can edit the <strong>grub.conf</strong> file to choose to use which kernel when booting.<br><img src="/images/compile-kernel/4.png" alt="Grub">  </p><p>Reboot the machine, and then you will find the new installed kernel in the booting screen.<br><img src="/images/compile-kernel/5.png" alt="Booting">  </p><p>[1]:  Love, Robert Love. (2003). Linux Kernel Development, 3, 40-42<br>[2]:  <a href="http://cateee.net/lkddb/web-lkddb/AIO.html" target="_blank" rel="noopener">http://cateee.net/lkddb/web-lkddb/AIO.html</a><br>[3]:  Love, Robert Love. (2003). Linux Kernel Development, 3, 42-43<br>[4]: Love, Robert Love. (2003). Linux Kernel Development, 3, 43-45</p>]]></content>
    
    <summary type="html">
    
      Tutorial on compiling your own linux kernel step by step
    
    </summary>
    
      <category term="kernel" scheme="http://tsaijin.github.io/categories/kernel/"/>
    
    
      <category term="linux" scheme="http://tsaijin.github.io/tags/linux/"/>
    
      <category term="kernel" scheme="http://tsaijin.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Read and Write functions in linux</title>
    <link href="http://tsaijin.github.io/2016/04/12/Read-and-Write-functions-in-linux/"/>
    <id>http://tsaijin.github.io/2016/04/12/Read-and-Write-functions-in-linux/</id>
    <published>2016-04-11T16:07:24.000Z</published>
    <updated>2020-04-13T11:45:24.247Z</updated>
    
    <content type="html"><![CDATA[<p>Resulting from work, I have learned I/O models of the linux operating system during these days. In linux operating system, various read and write APIs are provided to user space for use. Comparasions between them are illustraed below.  </p><a id="more"></a><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><code>read()</code> is the basic read function in linux environment. It attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.<br>It will start from current file offset. And the current file offset will be increased by the number of bytes read. However, if current file offset is at or past the end of operating file, no bytes will be read into buffer.<br>On success, the number of bytes read is returned (zero indicates end of file), and the file position is advanced by this number. It is not an error if this number is smaller than the number of bytes requested; this may happen for example because fewer bytes are actually available right now (maybe because we were close to end-of-file, or because we are reading from a pipe, or from a terminal), or because <code>read()</code> was interrupted by a signal. On error, -1 is returned, and errno is set appropriately. In this case it is left unspecified whether the file position (if any) changes.<a href="http://linux.die.net/man/2/read" target="_blank" rel="noopener">Reference</a><br><code>read()</code> is thread safe in the sense that your program will not have undefined behavior (crash or hung) if multiple threads perform IO on the same open file using at once. But the order and atomicity of these operations could vary greatly depending on the type of the file and the implementation of program.</p><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek()"></a>lseek()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>The <code>lseek()</code> function repositions the offset of the open file associated with the file descriptor fd to the argument offset according to the directive whence<br>The directive whence can be as follows:<br><strong>SEEK_SET</strong>         The offset is set to offset bytes.<br><strong>SEEK_CUR</strong>        The offset is set to its current location plus offset bytes.<br><strong>SEEK_END</strong>        The offset is set to the size of the file plus offset bytes.<br>When whence is as the last one, <code>lseek()</code> function allows the file offset to be set beyond the size of file while the file size still keeps the same. If data is latter write at this point, subsequent reads of the data in the gap (as a “hole”) return null bytes until data is actually written to this gap.  <a href="http://linux.die.net/man/2/lseek" target="_blank" rel="noopener">Reference</a><br>There are some special usage methods about <code>lseek()</code>:</p><ol><li><code>lseek(int fildes, 0, SEEK_SET)</code>:<br> move the read or write position to the start of the file</li><li><code>lseek(int fildes, 0, SEEK_END)</code>:<br> move the read or write position to the end of the file</li><li><code>lseek(int fildes, 0, SEEK_CUR)</code>:<br> get the current read or write position of the file</li></ol><p>With <code>lseek()</code>, you can implement the random I/O models of read and write easily.</p><h3 id="pread"><a href="#pread" class="headerlink" title="pread()"></a>pread()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>Similar to <code>read()</code>, <code>pread()</code> attempts to read count bytes from file descriptor fd at offset into buffer starting at buf. Unlike <code>read()</code>, the offset here will be not changed after the call of <code>pread</code><br>In many cases <code>pread()</code> is the only option when you’re dealing with threads reading from a database or such.<br>Compared with <code>read()</code>, <code>pread()</code> does more than <code>read()</code> on account of the time to positioning offset.  From the work mechanism of <code>pread()</code>,  we can find that it is like the combination of <code>read()</code> and <code>lseek()</code>. Nevertheless, performance of <code>pread()</code> is quite higher than the combination of <code>read()</code> and <code>lseek()</code>.<br>As mentioned above, <code>read()</code> function will be in mess when multiple threads or processes perform IO operations on the same open file because it will increase the current file offset. On the flip side, <code>pread()</code> do not change the position in the open file so it is more convenient to using in the scenario of multiple threads and processes.  </p><h3 id="pwrite"><a href="#pwrite" class="headerlink" title="pwrite()"></a>pwrite()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line">Returns: number of bytes written <span class="keyword">if</span> OK, −<span class="number">1</span> on error</span><br></pre></td></tr></table></figure><p>Calling <code>pwrite()</code> is equivalent to calling <code>lseek()</code> followed by a call to <code>write()</code>. Instead of calling <code>lseesk()</code> and <code>write()</code> separately, the combination of <code>lseek()</code> and <code>write()</code> is atomic operation in <code>pwrite()</code>.</p>]]></content>
    
    <summary type="html">
    
      Introduction to various Read and Write functions in linux.
    
    </summary>
    
      <category term="linux" scheme="http://tsaijin.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://tsaijin.github.io/tags/linux/"/>
    
      <category term="kernel" scheme="http://tsaijin.github.io/tags/kernel/"/>
    
      <category term="C" scheme="http://tsaijin.github.io/tags/C/"/>
    
  </entry>
  
</feed>
